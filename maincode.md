# main code
- Please make sure to enter your own dbid in allowedDbIds. The ID already entered is Kentaki's ID.
- If you use the command without authorization, the dbid will be displayed in all lowercase along with a message. Add the displayed id to allowedDbIds
  Be sure to enter it in lowercase as it will be converted to lowercase for comparison!!
- Only the minimum callbacks are defined in registeredCallbacks.
Please add them according to https://github.com/kentaki65/bloxd-code-loader#definitions-controlling-callback-behavior

  (The same goes for callbackDefinitions)
```js
const allowedDbIds = ["5hfyzhrl29vwqhxyvaahe"];
const registeredCallbacks = {
  tick: [],
  playerCommand: [],
  onPlayerJoin: [],
  playerLeave: [],
  onPlayerClick: []
};
const callbackDefinitions = {
  onPlayerClick: { returns: false},
  tick: { returns: false },
  onPlayerJoin: { returns: false },
  onPlayerChat: { returns: [false, null, "object", "string"] },
  playerCommand: { returns: [true, false] },
  onPlayerAttemptCraft: { returns: ["preventCraft"] },
  onPlayerChangeBlock: { returns: ["preventChange", "preventDrop"] },
  onWorldChangeBlock: { returns: ["preventChange", "preventDrop"] },
  onPlayerMoveItemOutOfInventory: { returns: ["preventChange"] },
  onPlayerMoveInvenItem: { returns: ["preventChange"] },
  onPlayerMoveItemIntoIdxs: { returns: ["preventChange"] },
  onPlayerSwapInvenSlots: { returns: ["preventChange"] },
  onPlayerMoveInvenItemWithAmt: { returns: ["preventChange"] },
  onPlayerAttemptAltAction: { returns: ["preventAction"] },
  onPlayerAttemptSpawnMob: { returns: ["preventSpawn"] },
  onWorldAttemptSpawnMob: { returns: ["preventSpawn"] },
  onWorldAttemptDespawnMob: { returns: ["preventDespawn"] },
  onPlayerDamagingOtherPlayer: { returns: ["preventDamage", "number"] },
  onPlayerDamagingMob: { returns: ["preventDamage", "number"] },
  onMobDamagingPlayer: { returns: ["preventDamage", "number"] },
  onMobDamagingOtherMob: { returns: ["preventDamage", "number"] },
  onPlayerKilledOtherPlayer: { returns: ["keepInventory"] },
  onMobKilledPlayer: { returns: ["keepInventory"] },
  onPlayerKilledMob: { returns: ["preventDrop"] },
  onMobKilledOtherMob: { returns: ["preventDrop"] },
  onRespawnRequest: { returns: [true, "object"] }
};
let p="setStandardChest";p+="ItemSlot";const setslot=api[p];let e="getStandardChest";e+="Items";const getslot=api[e];let i="getStandardChest";i+="ItemSlot";const itemget=api[i];
let USE_UNICODE_ENCODING = false;let _escapeInput="",_escapedResult="",_escapeIndex=0,_escapePlayerId=null,_escapePos=null,_escapeMeta=null;
loadedCodes={},globalDataStore={};codeNameMap={},registeredAutoCodes={},alreadyLogged={},tickCount=0,registeredTicks=[],CHEST_POSITIONS=[],_writeChunks=[],_writePos=null,_writePlayerId=null,_writeIndex=0,_writeMetadata=null;
for(const eventName in callbackDefinitions){let e=callbackDefinitions[eventName];!1===e.returns?globalThis[eventName]=(...e)=>{if(Array.isArray(registeredCallbacks[eventName]))for(let r of registeredCallbacks[eventName])try{r(...e)}catch(n){api.log(`${eventName} error from ${r._codeName||"unknown"}: ${n}`)}}:globalThis[eventName]=(...r)=>{if(Array.isArray(registeredCallbacks[eventName]))for(let n of registeredCallbacks[eventName])try{let t=n(...r);if(e.returns.includes(t)||e.returns.includes(typeof t))return t}catch(o){api.log(`${eventName} error from ${n._codeName||"unknown"}: ${o}`)}return!!e.returns.includes(!0)||void 0}}

/*Below is the callback definition*/
function tick(){let t=api.getBlock([0,0,0]);if(20===tickCount&&api.log("Start loading..."),40===tickCount&&("Chest"===t?(loadChestPositionsFromChest([0,0,0]),loadCodeMetadata(),loadAllAutoCodes()):api.log(`Chest not found (${t})`)),"object"==typeof registeredCallbacks&&Array.isArray(registeredCallbacks.tick))for(let c of registeredCallbacks.tick)try{let o=c._codeName||"NO_NAME";alreadyLogged[o]||(api.log("Running: "+o),alreadyLogged[o]=!0),c()}catch(e){api.log(`tick callback error: ${e}`)}try{writeCodeTick()}catch(l){api.log(`write error: ${l.message}`)}tickCount++}
function onPlayerChat(r,t,n){if(Array.isArray(registeredCallbacks.onPlayerChat)){for(let e of registeredCallbacks.onPlayerChat)try{let o=e(r,t,n);if(!1===o||null===o)return!1;if("string"==typeof o)return{[r]:{chatContent:o}}}catch(a){api.log(`onPlayerChat error from ${e._codeName||"unknown"}: ${a}`)}return!0}}
function playerCommand(e,s){let r=!1;if(Array.isArray(registeredCallbacks.playerCommand))for(let a of registeredCallbacks.playerCommand)try{!0===a(e,s)&&(r=!0)}catch(t){api.log(`playerCommand error from ${a._codeName||"unknown"}: ${t}`)}let n=s.trim().split(/\s+/),o=n[0].replace("/",""),d=n.slice(1);if("loadcode"===o){if(!isAuthorized(e))return api.sendMessage(e,"Not on the allow list!"+api.getPlayerDbId(e).toLowerCase()),!0;if(1===d.length){let l=d[0],i=codeNameMap[l];if(!i||!Array.isArray(i.SaveDestination))return api.sendMessage(e,`not found or invalid format for: '${l}'`),!0;try{loadCodeFromChests(i.SaveDestination,l),loadedCodes[l]=!0,api.sendMessage(e,`Reloaded '${l}'`)}catch(f){api.sendMessage(e,`Failed to reload '${l}': ${f.message}`)}return!0}return api.sendMessage(e,"How to use: /loadcode <codeName>"),!0}if("unload"===o){if(!isAuthorized(e))return api.sendMessage(e,"Not on the allow list!"+api.getPlayerDbId(e).toLowerCase()),!0;if(1!==d.length)return api.sendMessage(e,"How to use: /unload <codeName>"),!0;let g=d[0];return loadedCodes[g]?(unloadCode(g),delete loadedCodes[g],api.sendMessage(e,`Unloaded: '${g}'`),!0):(api.sendMessage(e,`Not loaded: '${g}'`),!0)}if("reloadauto"===o)return isAuthorized(e)?(loadAllAutoCodes(),api.sendMessage(e,"All auto codes reloaded."),!0):(api.sendMessage(e,"Not on the allow list!"+api.getPlayerDbId(e).toLowerCase()),!0);if("loadedcodes"===o){let u=Object.entries(codeNameMap);if(0===u.length)api.sendMessage(e,"No codes are currently loaded.");else for(let[$,c]of u){let y=c.codeType||"undefined",M=c.creator||"unknown",m=loadedCodes[$]?"✅":"❌";api.sendMessage(e,`[${m}] ${$} | type: ${y} | by: ${M}`)}return!0}if("removecode"===o){if(!isAuthorized(e))return api.sendMessage(e,"Not on the allow list!"+api.getPlayerDbId(e).toLowerCase()),!0;let p=d[0],C=codeNameMap[p];if(api.log(p+"\n"+JSON.stringify(C)),!C)return api.sendMessage(e,`The code '${p}' does not exist`),!0;let D=C.SaveDestination;if(!Array.isArray(D))return api.sendMessage(e,`'${p}' No chest associated with was found`),!0;for(let b of D)for(let h=0;h<=35;h++)setslot(b,h,"Air",0,e,{});return delete codeNameMap[p],delete loadedCodes[p],api.sendMessage(e,`'${p}' has been completely removed`),!0}if(r)return!0}

/*Function definition from here*/
function escapeCodeSync(t){return t.split("").map(t=>"\\u"+t.charCodeAt(0).toString(16).padStart(4,"0")).join("")}
readDataCode = (codeName) => globalDataStore[codeName] || null;
accessDataCode=(t,e="")=>{let l=globalDataStore[t];if(!l)return api.log(`Data code '${t}' is not loaded`),null;if(!e)return l;try{let r=e.split(/\.|\[|\]/).filter(Boolean);return r.reduce((t,e)=>t?t[e]:void 0,l)??null}catch{return null}};
setDataCodeValue=(e,t,l)=>{let r=globalDataStore[e];if(!r)return!1;let i=t.split(/\.|\[|\]/).filter(Boolean);if(0===i.length)return!1;let n=r;for(let o=0;o<i.length-1;o++){let $=i[o];("object"!=typeof n[$]||null===n[$])&&(n[$]={}),n=n[$]}n[i[i.length-1]]=l;let s=escapeCodeSync(JSON.stringify(r)),f=[];for(let a=0;300*a<s.length;a++)f.push(s.slice(300*a,(a+1)*300));let g=codeNameMap[e];if(!g||!Array.isArray(g.SaveDestination))return!1;for(let u of g.SaveDestination){for(let c=0;c<f.length;c++)setslot(u,c,"Code Block",1,api.getPlayerIds()[0],{customDisplayName:`code:${c}`,customAttributes:{[`code${c}`]:f[c]}});for(let h=f.length;h<34;h++)setslot(u,h,"Air",0,api.getPlayerIds()[0])}return!0};
function writeCodeToChest(t,e,a,i,s=!0){try{if("Chest"!==api.getBlock(t)&&api.setBlock(t,"Chest"),s&&"data"!==a.codeType)startEscapeCodeInChunks(e,i,t,a);else{_writeChunks=[];for(let o=0;o<Math.ceil(e.length/300);o++)_writeChunks.push(e.slice(300*o,(o+1)*300));_writePos=t,_writePlayerId=i,_writeIndex=0,_writeMetadata=a,registeredCallbacks.tick.includes(writeCodeTick)||registeredCallbacks.tick.push(writeCodeTick)}try{let n=[0,0,0];"Chest"!==api.getBlock(n)&&api.setBlock(n,"Chest");let r=itemget(n,35),c={SaveDestination:[]};if(r?.attributes?.customAttributes?.metadata)try{c=JSON.parse(r.attributes.customAttributes.metadata)}catch{}Array.isArray(c.SaveDestination)||(c.SaveDestination=[]),c.SaveDestination.some(e=>JSON.stringify(e)===JSON.stringify(t))||c.SaveDestination.push(t),setslot(n,35,"Book",1,i,{customDisplayName:"metadata",customAttributes:{metadata:JSON.stringify(c)}})}catch(l){api.log("SaveDestination registration failure: "+l.message)}a.codeName&&Array.isArray(a.SaveDestination)&&(codeNameMap[a.codeName]={SaveDestination:a.SaveDestination,creator:a.Creator||"unknown",codeType:a.codeType||""})}catch(u){api.log("writeCodeToChest Error: "+u.message)}}function writeCodeTick(){try{if(!_writePos)return;let e=[..._writePos];for(;_writeIndex<_writeChunks.length;){"Chest"!==api.getBlock(e)&&api.setBlock(e,"Chest");let t=_writeChunks.length-_writeIndex,l=Math.min(34,t);for(let s=0;s<l;s++)setslot(e,s,"Code Block",1,_writePlayerId,{customAttributes:{[`code${_writeIndex}`]:_writeChunks[_writeIndex]}}),api.log(`Writing slot: ${_writeIndex} pos: ${e}`),_writeIndex++;let i=JSON.parse(JSON.stringify(_writeMetadata));if(Array.isArray(i.dependencies)||(i.dependencies=[]),i.nextPos=_writeIndex<_writeChunks.length?[e[0],e[1]+1,e[2]]:null,setslot(e,35,"Book",1,_writePlayerId,{customAttributes:{metadata:JSON.stringify(i)}}),_writeIndex>=_writeChunks.length){api.broadcastMessage(`Code saved successfully! Number of characters: ${_writeChunks.join("").length}`),_writeChunks=[],_writePos=null,_writePlayerId=null,_writeIndex=0,_writeMetadata=null;let o=registeredCallbacks.tick.indexOf(writeCodeTick);o>=0&&registeredCallbacks.tick.splice(o,1);return}e=[e[0],e[1]+1,e[2]]}}catch(r){api.log("writeCodeTick Error: "+r.message)}}
function escapeCodeTick(){try{if("string"!=typeof _escapeInput||!_escapeInput.length)return;let e=Math.min(_escapeIndex+50,_escapeInput.length),t=_escapeInput.slice(_escapeIndex,e);if(_escapedResult+=t.split("").map(e=>"\\u"+e.charCodeAt(0).toString(16).padStart(4,"0")).join(""),(_escapeIndex=e)>=_escapeInput.length){api.log("Escape complete, start writing"),_writeChunks=[];for(let i=0;i<Math.ceil(_escapedResult.length/300);i++)_writeChunks.push(_escapedResult.slice(300*i,(i+1)*300));_writePos=_escapePos,_writePlayerId=_escapePlayerId,_writeIndex=0,_writeMetadata=_escapeMeta,registeredCallbacks.tick.includes(writeCodeTick)||registeredCallbacks.tick.push(writeCodeTick),_escapeInput="",_escapedResult="",_escapeIndex=0,_escapePlayerId=null,_escapePos=null,_escapeMeta=null;let l=registeredCallbacks.tick.indexOf(escapeCodeTick);l>=0&&registeredCallbacks.tick.splice(l,1)}}catch(c){api.log("escapeCodeTick Error: "+c.message)}}
function startEscapeCodeInChunks(t,c,s,a){try{_escapeInput=t,_escapedResult="",_escapeIndex=0,_escapePlayerId=c,_escapePos=s,_escapeMeta=a,registeredCallbacks.tick||(registeredCallbacks.tick=[]),registeredCallbacks.tick.includes(escapeCodeTick)||registeredCallbacks.tick.push(escapeCodeTick)}catch(e){api.log("startEscape Error: "+e.message)}}
function loadAutoWithDependencies(e){let t=codeNameMap[e];if(!t||!Array.isArray(t.SaveDestination)||"auto"!==t.codeType){api.log(`'${e}' information is invalid or not an auto code`);return}let i=Array.isArray(t.dependencies)?t.dependencies:[];for(let n of i){let o=codeNameMap[n];if(!o||!Array.isArray(o.SaveDestination)){api.log(`'${n}' does not exist`);return}loadedCodes[n]||(loadCodeFromChests(o.SaveDestination,n),loadedCodes[n]=!0,api.log(`Loaded: '${n}'`))}loadCodeFromChests(t.SaveDestination,e),registeredAutoCodes[e]=!0,api.log(`Loaded: '${e}'`)}
function registerCallbacks(e,l){for(let t in l){let a=l[t];a._codeName=e,registeredCallbacks[t]||(registeredCallbacks[t]=[]),registeredCallbacks[t]=registeredCallbacks[t].filter(l=>l._codeName!==e),registeredCallbacks[t].push(a)}}
function unloadCode(e){if(loadedCodes[e]){for(let o in registeredCallbacks)registeredCallbacks[o]=registeredCallbacks[o].filter(o=>o._codeName!==e);delete loadedCodes[e],api.log("Unloaded: "+e)}}
function unescapeCode(e){return e.replace(/\\u([\dA-Fa-f]{4})/g,(e,r)=>String.fromCharCode(parseInt(r,16)))};
function isAuthorized(e){let t=api.getPlayerDbId(e).toLowerCase();return allowedDbIds.includes(t)};
function removeFromSaveDestination(t){let e=[0,0,0];if("Chest"!==api.getBlock(e))return;let a=itemget(e,35);if(a?.attributes?.customAttributes?.metadata)try{let i=JSON.parse(a.attributes.customAttributes.metadata);if(Array.isArray(i.SaveDestination)){let s=i.SaveDestination.filter(e=>JSON.stringify(e)!==JSON.stringify(t));setslot(e,35,"Book",1,api.getPlayerIds()[0],{customDisplayName:"metadata",customAttributes:{metadata:JSON.stringify({SaveDestination:s})}}),api.log(`Remove from SaveDestination: ${JSON.stringify(t)}`)}}catch(n){api.log(`JSON error when deleting SaveDestination: ${n.message}`)}}
function loadCodeFromChests(chestPositions,codeName){let joined="";for(let chestPos of chestPositions){if(!Array.isArray(chestPos)||3!==chestPos.length)continue;let items=getslot(chestPos),codeChunks=[];for(let i=0;i<35;i++){let item=items[i],attr=item?.attributes?.customAttributes;attr?.[`code${i}`]&&(codeChunks[i]=attr[`code${i}`])}joined+=codeChunks.filter(Boolean).join("")}let meta=codeNameMap[codeName];if(!meta){api.log(`Loading stopped due to unregistered metadata: ${codeName}`);return}try{let unescaped=unescapeCode(joined);"data"===meta.codeType?(globalDataStore[codeName]=JSON.parse(unescaped),api.log(`dataCode ${codeName} Loading complete`)):eval(unescaped),loadedCodes[codeName]=chestPositions}catch(err){api.log("Eval/Data Load Error: "+err.message)}}
function loadChestPositionsFromChest(t){try{let e=itemget(t,35);if(e?.attributes?.customAttributes?.metadata){let a=JSON.parse(e.attributes.customAttributes.metadata);Array.isArray(a.SaveDestination)?(CHEST_POSITIONS=a.SaveDestination,api.log(`Read CHEST_POSITIONS: ${CHEST_POSITIONS.map(t=>`[${t}]`).join(", ")}`)):api.log("SaveDestination is not an array")}else api.log("Metadata does not exist")}catch(s){api.log(`Error loading CHEST_POSITIONS: ${s.message}`)}};
function loadCodeMetadata(){for(let e of(codeNameMap={},CHEST_POSITIONS)){if("Chest"!==api.getBlock(e)){removeFromSaveDestination(e);continue}let t=getslot(e)?.[35]?.attributes?.customAttributes?.metadata;if("string"==typeof t&&t.trim())try{let a=JSON.parse(t);a.codeName&&Array.isArray(a.SaveDestination)&&(codeNameMap[a.codeName]={SaveDestination:a.SaveDestination,creator:a.Creator||"unknown",codeType:a.codeType||""})}catch(o){api.log(`Meta loading failure: ${o.message}`)}else api.log(`Metadata not found: ${JSON.stringify(e)}`)}};
function loadAllAutoCodes(){let e=[],t=[];for(let o of CHEST_POSITIONS){let a=getslot(o);if(!Array.isArray(a))continue;let c="";for(let r=0;r<35;r++){let d=a[r]?.attributes?.customAttributes?.[`code${r}`];d&&(c+=d)}let s=a[35]?.attributes?.customAttributes?.metadata;if("string"!=typeof s||!s.trim())continue;let l;try{l=JSON.parse(s)}catch{api.log(`Metadata JSON parsing failure @ ${JSON.stringify(o)}`);continue}l.codeName&&"data"===l.codeType&&!loadedCodes[l.codeName]?e.push({pos:o,rawStr:c,meta:l}):l.codeName&&"auto"===l.codeType&&!registeredAutoCodes[l.codeName]&&t.push(l.codeName)}for(let{pos:m,rawStr:i,meta:u}of e)try{let f=unescapeCode(i);globalDataStore[u.codeName]=JSON.parse(f),loadedCodes[u.codeName]=[m],api.log(` datacode ${u.codeName}Loading successful`)}catch(n){api.log(` [dataLoadErr] ${u.codeName} : ${n.message}`)}for(let N of t)loadAutoWithDependencies(N)}
```
